<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Light Points</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: crosshair;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    .mode-selector {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 100;
    }

    .mode-btn {
      padding: 10px 24px;
      border: 2px solid;
      border-radius: 20px;
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .mode-btn.light {
      border-color: #00ffcc;
      color: #00ffcc;
    }

    .mode-btn.light:hover,
    .mode-btn.light.active {
      background: #00ffcc;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
    }

    .mode-btn.dark {
      border-color: #ff6699;
      color: #ff6699;
    }

    .mode-btn.dark:hover,
    .mode-btn.dark.active {
      background: #ff6699;
      color: #000;
      box-shadow: 0 0 20px rgba(255, 102, 153, 0.5);
    }
  </style>
</head>
<body>
  <div class="mode-selector">
    <button class="mode-btn light active" data-mode="light">正能量 ✦</button>
    <button class="mode-btn dark" data-mode="dark">暗能量 ◉</button>
  </div>

  <canvas id="background-animation"></canvas>

  <script>
    // === Global State ===
    let currentMode = 'light';
    const userPoints = new Map(); // key: "x,y,z" -> { x, y, z }
    let socket;
    const REMOVE_RADIUS = 0.1; // 3D space distance threshold
    let serverStartTime = null; // Server start timestamp for synced rotation
    const ROTATION_SPEED = 0.0001; // radians per millisecond

    // === Three.js Setup ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({
      canvas: document.getElementById('background-animation'),
      antialias: true
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    camera.position.z = 3;

    // === User Particles ===
    let userParticlesGeometry = new THREE.BufferGeometry();
    const userParticlesMaterial = new THREE.PointsMaterial({
      size: 0.02,
      color: '#00ffcc'
    });

    const userParticlesMesh = new THREE.Points(userParticlesGeometry, userParticlesMaterial);
    scene.add(userParticlesMesh);

    // === Raycaster for click detection ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const intersectPoint = new THREE.Vector3();

    // === Animation Loop ===
    function animate() {
      requestAnimationFrame(animate);

      // Calculate rotation based on server start time
      if (serverStartTime !== null) {
        const elapsed = Date.now() - serverStartTime;
        userParticlesMesh.rotation.y = elapsed * ROTATION_SPEED;
      }

      renderer.render(scene, camera);
    }
    animate();

    // === Window Resize ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // === Mode Switching ===
    const modeButtons = document.querySelectorAll('.mode-btn');
    modeButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;
      });
    });

    // === Click Handler ===
    document.addEventListener('click', (e) => {
      if (e.target.closest('.mode-selector')) return;

      // Convert mouse to NDC
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      // Raycast to Z=0 plane for X,Y position
      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(planeZ, intersectPoint);

      if (!intersectPoint) return;

      const x = intersectPoint.x;
      const y = intersectPoint.y;

      if (currentMode === 'light') {
        const z = (Math.random() - 0.5) * 2; // Random Z between -1 and 1
        sendMessage({ type: 'add', point: { x, y, z } });
      } else {
        // Dark mode: find nearest by X,Y only (ignore Z depth)
        const nearest = findNearestPoint2D(x, y);
        if (nearest && nearest.dist <= REMOVE_RADIUS) {
          sendMessage({ type: 'remove', point: { x: nearest.x, y: nearest.y, z: nearest.z } });
        }
      }
    });

    // === WebSocket ===
    connectSocket();

    function connectSocket() {
      socket = new WebSocket(`ws://${location.host}/ws`);

      socket.addEventListener('open', () => {
        console.log('ws connected');
      });

      socket.addEventListener('message', (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleServerMessage(msg);
        } catch (err) {
          console.error('invalid ws message', err);
        }
      });

      socket.addEventListener('close', () => {
        console.warn('ws closed, retrying...');
        setTimeout(connectSocket, 1000);
      });

      socket.addEventListener('error', (err) => {
        console.error('ws error', err);
      });
    }

    function handleServerMessage(msg) {
      if (!msg || !msg.type) return;

      switch (msg.type) {
        case 'init':
          if (msg.startTime) {
            serverStartTime = msg.startTime;
          }
          if (Array.isArray(msg.points)) {
            msg.points.forEach(addPointLocal);
          }
          break;
        case 'add':
          if (msg.point) addPointLocal(msg.point);
          break;
        case 'remove':
          if (msg.point) removePointLocal(msg.point);
          break;
        default:
          console.warn('unknown message type', msg.type);
      }
    }

    function sendMessage(payload) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(payload));
      } else {
        console.warn('ws not ready, skip', payload);
      }
    }

    // === Point Management ===
    function makeKey(x, y, z) {
      return `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;
    }

    function addPointLocal({ x, y, z }) {
      const key = makeKey(x, y, z);
      if (userPoints.has(key)) return;
      userPoints.set(key, { x, y, z });
      updateUserParticles();
    }

    function removePointLocal({ x, y, z }) {
      const key = makeKey(x, y, z);
      if (!userPoints.has(key)) return;
      userPoints.delete(key);
      updateUserParticles();
    }

    function updateUserParticles() {
      const positions = new Float32Array(userPoints.size * 3);
      let i = 0;
      userPoints.forEach(({ x, y, z }) => {
        positions[i++] = x;
        positions[i++] = y;
        positions[i++] = z;
      });

      userParticlesGeometry.dispose();
      userParticlesGeometry = new THREE.BufferGeometry();
      userParticlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      userParticlesMesh.geometry = userParticlesGeometry;
    }

    function findNearestPoint2D(x, y) {
      let best = null;
      let bestDist = Infinity;

      // Account for rotation when finding nearest (only X,Y distance)
      // Use same time-based calculation as animation loop
      const elapsed = serverStartTime !== null ? Date.now() - serverStartTime : 0;
      const rotationY = elapsed * ROTATION_SPEED;
      const cosR = Math.cos(-rotationY);
      const sinR = Math.sin(-rotationY);

      userPoints.forEach((entry) => {
        // Apply inverse rotation to stored point to get world position
        const wx = entry.x * cosR - entry.z * sinR;

        // Only calculate 2D distance (X, Y)
        const dist = Math.sqrt(
          Math.pow(wx - x, 2) +
          Math.pow(entry.y - y, 2)
        );

        if (dist < bestDist) {
          bestDist = dist;
          best = { x: entry.x, y: entry.y, z: entry.z, dist };
        }
      });

      return best;
    }
  </script>
</body>
</html>
